import numpy as np
import matplotlib.pyplot as plt
import support_files_car as sfc
import matplotlib.gridspec as gridspec
import matplotlib.animation as animation

import platform
print("Python " + platform.python_version())
import numpy as np
print("Numpy " + np.__version__)
import matplotlib
print("Matplotlib " + matplotlib.__version__)

# Create an object for the support functions.
support = sfc.SupportFilesCar()
constants = support.constants

# Load the constant values needed in the main file
Ts = constants['Ts']  # Định nghĩa Ts từ constants
outputs = constants['outputs']  # number of outputs (psi, Y)
hz = constants['hz']  # horizon prediction period increased to 40
x_dot_ref = constants['x_dot']  # reference longitudinal velocity
time_length = constants['time_length']  # duration of the manoeuvre

# Generate the reference signals
t = np.arange(0, time_length + Ts, Ts)  # Sử dụng Ts từ constants
r = constants['r']
f = constants['f']
psi_ref, X_ref, Y_ref = support.trajectory_generator(t, r, f)
curvature = np.gradient(psi_ref, t)  # Ước lượng độ cong quỹ đạo
x_dot_ref_signal = np.where(abs(curvature) > 0.1, 10.0, 20.0)  # Giảm tốc xuống 10 m/s nếu độ cong lớn

sim_length = len(t)  # Number of control loop iterations
refSignals = np.zeros(len(X_ref) * outputs)

# Build up the reference signal vector
k = 0
for i in range(0, len(refSignals), outputs):
    refSignals[i] = psi_ref[k]
    refSignals[i + 1] = Y_ref[k]
    k = k + 1

# Load the initial states
y_dot = 0.
psi = 0.
psi_dot = 0.
Y = Y_ref[0] + 10.
x_dot = x_dot_ref

states = np.array([y_dot, psi, psi_dot, Y, x_dot])
statesTotal = np.zeros((len(t), len(states)))
statesTotal[0][0:len(states)] = states
psi_opt_total = np.zeros((len(t), hz))
Y_opt_total = np.zeros((len(t), hz))
x_dot_total = np.zeros(len(t))

# Load the initial input
U1 = 0
UTotal = np.zeros(len(t))
UTotal[0] = U1
U_long = 0

# To extract psi_opt from predicted x_aug_opt
C_psi_opt = np.zeros((hz, (len(states) - 1 + np.size(U1)) * hz))
for i in range(1, hz + 1):
    C_psi_opt[i - 1][i + 4 * (i - 1)] = 1

# To extract Y_opt from predicted x_aug_opt
C_Y_opt = np.zeros((hz, (len(states) - 1 + np.size(U1)) * hz))
for i in range(3, hz + 3):
    C_Y_opt[i - 3][i + 4 * (i - 3)] = 1

# Generate the discrete state space matrices
Ad, Bd, Cd, Dd = support.state_space()

# Generate the compact simplification matrices for the cost function
Hdb, Fdbt, Cdb, Adc = support.mpc_simplification(Ad, Bd, Cd, Dd, hz)

# Initiate the controller - simulation loops
k = 0
for i in range(0, sim_length - 1):
    # Ước lượng trạng thái bằng Kalman Filter
    measured_states = states + np.random.normal(0, 0.01, len(states))
    states = support.kalman_filter(measured_states, U1, states)

    # Generate the augmented current state and the reference vector
    x_aug_t = np.transpose([np.concatenate((states[:-1], [U1]), axis=0)])

    k = k + outputs
    if k + outputs * hz <= len(refSignals):
        r = refSignals[k:k + outputs * hz]
    else:
        r = refSignals[k:len(refSignals)]
        hz = hz - 1

    if hz < constants['hz']:
        Hdb, Fdbt, Cdb, Adc = support.mpc_simplification(Ad, Bd, Cd, Dd, hz)

    ft = np.matmul(np.concatenate((np.transpose(x_aug_t)[0][0:len(x_aug_t)], r), axis=0), Fdbt)
    du = -np.matmul(np.linalg.inv(Hdb), np.transpose([ft]))

    # Thêm ràng buộc tốc độ thay đổi góc lái
    max_steering_rate = 0.2
    if abs(du[0][0] / Ts) > max_steering_rate:
        du[0][0] = np.sign(du[0][0]) * max_steering_rate * Ts

    x_aug_opt = np.matmul(Cdb, du) + np.matmul(Adc, x_aug_t)
    psi_opt = np.matmul(C_psi_opt[0:hz, 0:(len(states) - 1 + np.size(U1)) * hz], x_aug_opt)
    Y_opt = np.matmul(C_Y_opt[0:hz, 0:(len(states) - 1 + np.size(U1)) * hz], x_aug_opt)
    psi_opt = np.transpose((psi_opt))[0]
    psi_opt_total[i + 1][0:hz] = psi_opt
    Y_opt = np.transpose((Y_opt))[0]
    Y_opt_total[i + 1][0:hz] = Y_opt

    # Update the real inputs
    U1 = U1 + du[0][0]

    ######################### PID #############################################
    PID_switch = constants['PID_switch']

    if PID_switch == 1:
        if i == 0:
            e_int_pid_yaw = 0
            e_int_pid_Y = 0
            e_pid_yaw_i = psi_ref[0] - states[1]
            e_dot_pid_yaw = 0
            # Adjusted PID gains for stability
            U1_yaw = 2.0 * e_pid_yaw_i + 1.0 * e_dot_pid_yaw + 0.5 * e_int_pid_yaw

            e_pid_Y_i = Y_ref[0] - states[3]
            e_dot_pid_Y = 0
            U1_Y = 2.0 * e_pid_Y_i + 1.0 * e_dot_pid_Y + 0.5 * e_int_pid_Y

            U1 = U1_yaw + U1_Y
        else:
            e_pid_yaw_im1 = psi_ref[i - 1] - old_states[1]
            e_pid_yaw_i = psi_ref[i] - states[1]
            e_dot_pid_yaw = (e_pid_yaw_i - e_pid_yaw_im1) / Ts
            e_int_pid_yaw = e_int_pid_yaw + (e_pid_yaw_im1 + e_pid_yaw_i) / 2 * Ts
            # Adjusted PID gains for stability
            U1_yaw = 2.0 * e_pid_yaw_i + 1.0 * e_dot_pid_yaw + 0.5 * e_int_pid_yaw

            e_pid_Y_im1 = Y_ref[i - 1] - old_states[3]
            e_pid_Y_i = Y_ref[i] - states[3]
            e_dot_pid_Y = (e_pid_Y_i - e_pid_Y_im1) / Ts
            e_int_pid_Y = e_int_pid_Y + (e_pid_Y_im1 + e_pid_Y_i) / 2 * Ts
            U1_Y = 2.0 * e_pid_Y_i + 1.0 * e_dot_pid_Y + 0.5 * e_int_pid_Y

            U1 = U1_yaw + U1_Y

        old_states = states
    ######################### PID END #########################################

    # Bổ sung điều khiển dọc
    U_long = support.longitudinal_control(x_dot_ref_signal[i], states[4])

    # Establish the limits for the real inputs
    if U1 < -np.pi / 4:
        U1 = -np.pi / 4
    elif U1 > np.pi / 4:
        U1 = np.pi / 4

    UTotal[i + 1] = U1
    x_dot_total[i + 1] = states[4] + U_long * Ts

    states = support.open_loop_new_states(states, U1)
    statesTotal[i + 1][0:len(states)] = states

################################ ANIMATION LOOP ###############################
frame_amount = int(time_length / Ts)
lf = constants['lf']
lr = constants['lr']
def update_plot(num):
    hz = constants['hz']

    car_1.set_data([X_ref[num] - lr * np.cos(statesTotal[num, 1]), X_ref[num] + lf * np.cos(statesTotal[num, 1])],
                   [statesTotal[num, 3] - lr * np.sin(statesTotal[num, 1]), statesTotal[num, 3] + lf * np.sin(statesTotal[num, 1])])

    car_1_body.set_data([-lr * np.cos(statesTotal[num, 1]), lf * np.cos(statesTotal[num, 1])],
                        [-lr * np.sin(statesTotal[num, 1]), lf * np.sin(statesTotal[num, 1])])

    car_1_body_extension.set_data([0, (lf + 40) * np.cos(statesTotal[num, 1])],
                                  [0, (lf + 40) * np.sin(statesTotal[num, 1])])

    track_width = 1.5
    psi_body = statesTotal[num, 1]
    r_rear_outer = -(lr + 0.5)
    r_rear_inner = -(lr - 0.5)

    car_1_back_left.set_data(
        [r_rear_outer * np.cos(psi_body) - (track_width / 2) * np.sin(psi_body),
         r_rear_inner * np.cos(psi_body) - (track_width / 2) * np.sin(psi_body)],
        [r_rear_outer * np.sin(psi_body) + (track_width / 2) * np.cos(psi_body),
         r_rear_inner * np.sin(psi_body) + (track_width / 2) * np.cos(psi_body)]
    )

    car_1_back_right.set_data(
        [r_rear_outer * np.cos(psi_body) + (track_width / 2) * np.sin(psi_body),
         r_rear_inner * np.cos(psi_body) + (track_width / 2) * np.sin(psi_body)],
        [r_rear_outer * np.sin(psi_body) - (track_width / 2) * np.cos(psi_body),
         r_rear_inner * np.sin(psi_body) - (track_width / 2) * np.cos(psi_body)]
    )

    f_front_outer = lf - 0.5
    f_front_inner = lf + 0.5
    steer = UTotal[num]

    car_1_front_left.set_data(
        [lf * np.cos(psi_body) - 0.5 * np.cos(psi_body + steer) - (track_width / 2) * np.sin(psi_body),
         lf * np.cos(psi_body) + 0.5 * np.cos(psi_body + steer) - (track_width / 2) * np.sin(psi_body)],
        [lf * np.sin(psi_body) - 0.5 * np.sin(psi_body + steer) + (track_width / 2) * np.cos(psi_body),
         lf * np.sin(psi_body) + 0.5 * np.sin(psi_body + steer) + (track_width / 2) * np.cos(psi_body)]
    )

    car_1_front_right.set_data(
        [lf * np.cos(psi_body) - 0.5 * np.cos(psi_body + steer) + (track_width / 2) * np.sin(psi_body),
         lf * np.cos(psi_body) + 0.5 * np.cos(psi_body + steer) + (track_width / 2) * np.sin(psi_body)],
        [lf * np.sin(psi_body) - 0.5 * np.sin(psi_body + steer) - (track_width / 2) * np.cos(psi_body),
         lf * np.sin(psi_body) + 0.5 * np.sin(psi_body + steer) - (track_width / 2) * np.cos(psi_body)]
    )

    car_1_front_wheel_extension.set_data([lf * np.cos(psi_body), lf * np.cos(psi_body) + (0.5 + 40) * np.cos(psi_body + UTotal[num])],
                                         [lf * np.sin(psi_body), lf * np.sin(psi_body) + (0.5 + 40) * np.sin(psi_body + UTotal[num])])

    yaw_angle_text.set_text(str(round(statesTotal[num, 1], 2)) + ' rad')
    steer_angle.set_text(str(round(UTotal[num], 2)) + ' rad')

    steering_wheel.set_data(t[0:num], UTotal[0:num])
    yaw_angle.set_data(t[0:num], statesTotal[0:num, 1])
    Y_position.set_data(t[0:num], statesTotal[0:num, 3])
    x_dot_plot.set_data(t[0:num], x_dot_total[0:num])

    if num + hz > len(t):
        hz = len(t) - num
    if PID_switch != 1 and num != 0:
        Y_predicted.set_data(t[num:num + hz], Y_opt_total[num][0:hz])
        psi_predicted.set_data(t[num:num + hz], psi_opt_total[num][0:hz])
        car_predicted.set_data(X_ref[num:num + hz], Y_opt_total[num][0:hz])
    car_determined.set_data(X_ref[0:num], statesTotal[0:num, 3])

    if PID_switch != 1:
        return car_1, car_1_body, car_1_body_extension, \
               car_1_back_left, car_1_back_right, car_1_front_left, car_1_front_right, car_1_front_wheel_extension, \
               yaw_angle_text, steer_angle, steering_wheel, \
               yaw_angle, Y_position, car_determined, Y_predicted, psi_predicted, car_predicted, x_dot_plot
    else:
        return car_1, car_1_body, car_1_body_extension, \
               car_1_back_left, car_1_back_right, car_1_front_left, car_1_front_right, car_1_front_wheel_extension, \
               yaw_angle_text, steer_angle, steering_wheel, yaw_angle, Y_position, car_determined, x_dot_plot

# Set up your figure properties
fig_x = 16
fig_y = 9
fig = plt.figure(figsize=(fig_x, fig_y), dpi=120, facecolor=(0.8, 0.8, 0.8))
n = 3
m = 4
gs = gridspec.GridSpec(n, m)

# Car motion
ax0 = fig.add_subplot(gs[0, :], facecolor=(0.9, 0.9, 0.9))
ref_trajectory = ax0.plot(X_ref, Y_ref, 'b', linewidth=1)

lane_width = constants['lane_width']
lane_1, = ax0.plot([X_ref[0], X_ref[frame_amount]], [lane_width / 2, lane_width / 2], 'k', linewidth=0.2)
lane_2, = ax0.plot([X_ref[0], X_ref[frame_amount]], [-lane_width / 2, -lane_width / 2], 'k', linewidth=0.2)
lane_3, = ax0.plot([X_ref[0], X_ref[frame_amount]], [lane_width / 2 + lane_width, lane_width / 2 + lane_width], 'k', linewidth=0.2)
lane_4, = ax0.plot([X_ref[0], X_ref[frame_amount]], [-lane_width / 2 - lane_width, -lane_width / 2 - lane_width], 'k', linewidth=0.2)
lane_5, = ax0.plot([X_ref[0], X_ref[frame_amount]], [lane_width / 2 + 2 * lane_width, lane_width / 2 + 2 * lane_width], 'k', linewidth=3)
lane_6, = ax0.plot([X_ref[0], X_ref[frame_amount]], [-lane_width / 2 - 2 * lane_width, -lane_width / 2 - 2 * lane_width], 'k', linewidth=3)

car_1, = ax0.plot([], [], 'k', linewidth=3)
car_predicted, = ax0.plot([], [], '-m', linewidth=1)
car_determined, = ax0.plot([], [], '-r', linewidth=1)

plt.xlim(X_ref[0], X_ref[frame_amount])
plt.ylim(-X_ref[frame_amount] / (n * (fig_x / fig_y) * 2), X_ref[frame_amount] / (n * (fig_x / fig_y) * 2))
plt.ylabel('Y-distance [m]', fontsize=15)

# Create an object for the motorcycle (zoomed)
ax1 = fig.add_subplot(gs[1, :], facecolor=(0.9, 0.9, 0.9))
bbox_props_angle = dict(boxstyle='square', fc=(0.9, 0.9, 0.9), ec='k', lw=1.0)
bbox_props_steer_angle = dict(boxstyle='square', fc=(0.9, 0.9, 0.9), ec='r', lw=1.0)

neutral_line = ax1.plot([-50, 50], [0, 0], 'k', linewidth=1)
car_1_body, = ax1.plot([], [], 'k', linewidth=3)
car_1_body_extension, = ax1.plot([], [], '--k', linewidth=1)
car_1_back_left, = ax1.plot([], [], 'r', linewidth=4)
car_1_back_right, = ax1.plot([], [], 'r', linewidth=4)
car_1_front_left, = ax1.plot([], [], 'r', linewidth=4)
car_1_front_right, = ax1.plot([], [], 'r', linewidth=4)
car_1_front_wheel_extension, = ax1.plot([], [], '--r', linewidth=1)

n1_start = -5
n1_finish = 30
plt.xlim(n1_start, n1_finish)
plt.ylim(-(n1_finish - n1_start) / (n * (fig_x / fig_y) * 2), (n1_finish - n1_start) / (n * (fig_x / fig_y) * 2))
plt.ylabel('Y-distance [m]', fontsize=15)
yaw_angle_text = ax1.text(25, 2, '', size='20', color='k', bbox=bbox_props_angle)
steer_angle = ax1.text(25, -2.5, '', size='20', color='r', bbox=bbox_props_steer_angle)

# Create the function for the steering wheel
ax2 = fig.add_subplot(gs[2, 0], facecolor=(0.9, 0.9, 0.9))
steering_wheel, = ax2.plot([], [], '-r', linewidth=1, label='steering angle [rad]')
plt.xlim(0, t[-1])
plt.ylim(np.min(UTotal) - 0.1, np.max(UTotal) + 0.1)
plt.xlabel('time [s]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')

# Create the function for the yaw angle
ax3 = fig.add_subplot(gs[2, 1], facecolor=(0.9, 0.9, 0.9))
yaw_angle_reference = ax3.plot(t, psi_ref, '-b', linewidth=1, label='yaw reference [rad]')
yaw_angle, = ax3.plot([], [], '-r', linewidth=1, label='yaw angle [rad]')
if PID_switch != 1:
    psi_predicted, = ax3.plot([], [], '-m', linewidth=3, label='psi - predicted [rad]')
plt.xlim(0, t[-1])
plt.ylim(np.min(statesTotal[:, 1]) - 0.1, np.max(statesTotal[:, 1]) + 0.1)
plt.xlabel('time [s]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')

# Create the function for the Y-position
ax4 = fig.add_subplot(gs[2, 2], facecolor=(0.9, 0.9, 0.9))
Y_position_reference = ax4.plot(t, Y_ref, '-b', linewidth=1, label='Y - reference [m]')
Y_position, = ax4.plot([], [], '-r', linewidth=1, label='Y - position [m]')
if PID_switch != 1:
    Y_predicted, = ax4.plot([], [], '-m', linewidth=3, label='Y - predicted [m]')
plt.xlim(0, t[-1])
plt.ylim(np.min(statesTotal[:, 3]) - 2, np.max(statesTotal[:, 3]) + 2)
plt.xlabel('time [s]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')

# Bổ sung plot cho tốc độ dọc
ax5 = fig.add_subplot(gs[2, 3], facecolor=(0.9, 0.9, 0.9))
x_dot_ref_plot = ax5.plot(t, x_dot_ref_signal, '-b', linewidth=1, label='x_dot ref [m/s]')
x_dot_plot, = ax5.plot([], [], '-r', linewidth=1, label='x_dot [m/s]')
plt.xlim(0, t[-1])
plt.ylim(np.min(x_dot_total) - 1, np.max(x_dot_total) + 1)
plt.xlabel('time [s]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')

car_ani = animation.FuncAnimation(fig, update_plot,
                                  frames=frame_amount, interval=20, repeat=True, blit=True)
plt.show()

# Plot the world
plt.plot(X_ref, Y_ref, 'b', linewidth=2, label='The trajectory')
plt.plot(X_ref, statesTotal[:, 3], '--r', linewidth=2, label='Car position')
plt.xlabel('x-position [m]', fontsize=15)
plt.ylabel('y-position [m]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')
plt.ylim(-X_ref[-1] / 2, X_ref[-1] / 2)
plt.show()

# Plot the the input delta(t) and the outputs: psi(t) and Y(t)
plt.subplot(4, 1, 1)
plt.plot(t, UTotal[:], 'r', linewidth=2, label='steering wheel angle')
plt.xlabel('t-time [s]', fontsize=15)
plt.ylabel('steering wheel angle [rad]', fontsize=15)
plt.grid(True)
plt.legend(loc='upper right', fontsize='small')

plt.subplot(4, 1, 2)
plt.plot(t, psi_ref, 'b', linewidth=2, label='Yaw_ref angle')
plt.plot(t, statesTotal[:, 1], '--r', linewidth=2, label='Car yaw angle')
plt.xlabel('t-time [s]', fontsize=15)
plt.ylabel('psi_ref-position [rad]', fontsize=15)
plt.grid(True)
plt.legend(loc='center right', fontsize='small')

plt.subplot(4, 1, 3)
plt.plot(t, Y_ref, 'b', linewidth=2, label='Y_ref position')
plt.plot(t, statesTotal[:, 3], '--r', linewidth=2, label='Car Y position')
plt.xlabel('t-time [s]', fontsize=15)
plt.ylabel('y-position [m]', fontsize=15)
plt.grid(True)
plt.legend(loc='center right', fontsize='small')

plt.subplot(4, 1, 4)
plt.plot(t, x_dot_ref_signal, 'b', linewidth=2, label='x_dot ref')
plt.plot(t, statesTotal[:, 4], '--r', linewidth=2, label='x_dot')
plt.xlabel('t-time [s]', fontsize=15)
plt.ylabel('longitudinal velocity [m/s]', fontsize=15)
plt.grid(True)
plt.legend(loc='center right', fontsize='small')
plt.show()

# Plot errors
plt.figure()
plt.subplot(3, 1, 1)
plt.plot(t, psi_ref - statesTotal[:, 1], 'g', linewidth=2, label='Yaw error')
plt.xlabel('time [s]', fontsize=15)
plt.ylabel('e_psi [rad]', fontsize=15)
plt.grid(True)
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(t, Y_ref - statesTotal[:, 3], 'g', linewidth=2, label='Lateral position error')
plt.xlabel('time [s]', fontsize=15)
plt.ylabel('e_y [m]', fontsize=15)
plt.grid(True)
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(t, x_dot_ref_signal - statesTotal[:, 4], 'g', linewidth=2, label='Longitudinal velocity error')
plt.xlabel('time [s]', fontsize=15)
plt.ylabel('e_v [m/s]', fontsize=15)
plt.grid(True)
plt.legend()
plt.show()

if constants['PID_switch'] == 1:
    print("The simulation was done with the PID controller")
else:
    print("The simulation was done with the MPC controller")
    print("The prediction horizon was: " + str(constants['hz']) + " samples")
    print("The simulation is done for: " + str(constants['time_length']) + " seconds")
    print("The sample time is: " + str(constants['Ts']) + " seconds")
    print("The constant longitudinal velocity is: " + str(constants['x_dot']) + " m/s")
    print("The trajectory chosen is number: " + str(constants['trajectory']))
    print("The mass of the car is: " + str(constants['m']) + " kg")
    print("The cornering stiffness of the front tyre is: " + str(constants['Caf']) + " N/rad")
    print("The cornering stiffness of the rear tyre is: " + str(constants['Car']) + " N/rad")
    print("The distance from the center of gravity to the front axle is: " + str(constants['lf']) + " m")
    print("The distance from the center of gravity to the rear axle is: " + str(constants['lr']) + " m")
    print("The moment of inertia of the car is: " + str(constants['Iz']) + " kgm^2")
    print("The lane width is: " + str(constants['lane_width']) + " m")
    print("The amplitude of the road disturbance is: " + str(constants['r']) + " m")
    print("The frequency of the road disturbance is: " + str(constants['f']) + " 1/m")
    print("The weights in the cost function are adaptive based on curvature.")
